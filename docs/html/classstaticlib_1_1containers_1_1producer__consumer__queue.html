<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>staticlib_containers: staticlib::containers::producer_consumer_queue&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">staticlib_containers
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestaticlib.html">staticlib</a></li><li class="navelem"><a class="el" href="namespacestaticlib_1_1containers.html">containers</a></li><li class="navelem"><a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html">producer_consumer_queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstaticlib_1_1containers_1_1producer__consumer__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">staticlib::containers::producer_consumer_queue&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>ProducerConsumerQueue is a one producer and one consumer queue without locks.  
 <a href="classstaticlib_1_1containers_1_1producer__consumer__queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="producer__consumer__queue_8hpp_source.html">staticlib/containers/producer_consumer_queue.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af0cc4804a42b5a7e5247f0e3485abef6"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html#af0cc4804a42b5a7e5247f0e3485abef6">value_type</a></td></tr>
<tr class="memdesc:af0cc4804a42b5a7e5247f0e3485abef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of elements.  <a href="#af0cc4804a42b5a7e5247f0e3485abef6"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2b77b2e20ae6533abe08d5e3f659afad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html#a2b77b2e20ae6533abe08d5e3f659afad">producer_consumer_queue</a> (uint32_t size)</td></tr>
<tr class="memdesc:a2b77b2e20ae6533abe08d5e3f659afad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, note that the number of usable slots in the queue at any given time is actually (size-1), so if you start with an empty queue, isFull() will return true after size-1 insertions.  <a href="#a2b77b2e20ae6533abe08d5e3f659afad"></a><br/></td></tr>
<tr class="memitem:a6f94b8e0d625cbac2abbf7c6150f7094"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html#a6f94b8e0d625cbac2abbf7c6150f7094">~producer_consumer_queue</a> ()</td></tr>
<tr class="memdesc:a6f94b8e0d625cbac2abbf7c6150f7094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a6f94b8e0d625cbac2abbf7c6150f7094"></a><br/></td></tr>
<tr class="memitem:a73b160dd1c7f4e5a7a1bdffd1ffcfbc1"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a73b160dd1c7f4e5a7a1bdffd1ffcfbc1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html#a73b160dd1c7f4e5a7a1bdffd1ffcfbc1">emplace</a> (Args &amp;&amp;...record_args)</td></tr>
<tr class="memdesc:a73b160dd1c7f4e5a7a1bdffd1ffcfbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a value at the end of the queue.  <a href="#a73b160dd1c7f4e5a7a1bdffd1ffcfbc1"></a><br/></td></tr>
<tr class="memitem:a5a6770161ad64f1f62f3b3d473c72dbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html#a5a6770161ad64f1f62f3b3d473c72dbb">poll</a> (T &amp;record)</td></tr>
<tr class="memdesc:a5a6770161ad64f1f62f3b3d473c72dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read the value at the front to the queue into a variable.  <a href="#a5a6770161ad64f1f62f3b3d473c72dbb"></a><br/></td></tr>
<tr class="memitem:adf38708481d5d821a0ff17b412feae0a"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html#adf38708481d5d821a0ff17b412feae0a">front_ptr</a> ()</td></tr>
<tr class="memdesc:adf38708481d5d821a0ff17b412feae0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the item at the front of the queue.  <a href="#adf38708481d5d821a0ff17b412feae0a"></a><br/></td></tr>
<tr class="memitem:a8935b023185f090c72d432255883de10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html#a8935b023185f090c72d432255883de10">is_empty</a> () const </td></tr>
<tr class="memdesc:a8935b023185f090c72d432255883de10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the queue is empty.  <a href="#a8935b023185f090c72d432255883de10"></a><br/></td></tr>
<tr class="memitem:ad1fa2cd53e50b4889dddc7700d57af4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html#ad1fa2cd53e50b4889dddc7700d57af4c">is_full</a> () const </td></tr>
<tr class="memdesc:ad1fa2cd53e50b4889dddc7700d57af4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the queue is full.  <a href="#ad1fa2cd53e50b4889dddc7700d57af4c"></a><br/></td></tr>
<tr class="memitem:a990d1469d76c4b7102de7619c80ee6f2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html#a990d1469d76c4b7102de7619c80ee6f2">size_guess</a> () const </td></tr>
<tr class="memdesc:a990d1469d76c4b7102de7619c80ee6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries in the queue.  <a href="#a990d1469d76c4b7102de7619c80ee6f2"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class staticlib::containers::producer_consumer_queue&lt; T &gt;</h3>

<p>ProducerConsumerQueue is a one producer and one consumer queue without locks. </p>
<p>See docs: <a href="https://github.com/facebook/folly/blob/master/folly/docs/ProducerConsumerQueue.md">https://github.com/facebook/folly/blob/master/folly/docs/ProducerConsumerQueue.md</a> Note, 'popFront' method was removed as it didn't work properly with MSVC. </p>
</div><h2>Member Typedef Documentation</h2>
<a class="anchor" id="af0cc4804a42b5a7e5247f0e3485abef6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html">staticlib::containers::producer_consumer_queue</a>&lt; T &gt;::<a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html#af0cc4804a42b5a7e5247f0e3485abef6">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of elements. </p>

</div>
</div>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2b77b2e20ae6533abe08d5e3f659afad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html">staticlib::containers::producer_consumer_queue</a>&lt; T &gt;::<a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html">producer_consumer_queue</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor, note that the number of usable slots in the queue at any given time is actually (size-1), so if you start with an empty queue, isFull() will return true after size-1 insertions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>queue size, must be &gt;= 2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f94b8e0d625cbac2abbf7c6150f7094"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html">staticlib::containers::producer_consumer_queue</a>&lt; T &gt;::~<a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html">producer_consumer_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a73b160dd1c7f4e5a7a1bdffd1ffcfbc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html">staticlib::containers::producer_consumer_queue</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>record_args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace a value at the end of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordArgs</td><td>constructor arguments for queue element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the queue was full, true otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="adf38708481d5d821a0ff17b412feae0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html">staticlib::containers::producer_consumer_queue</a>&lt; T &gt;::front_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a pointer to the item at the front of the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the item, nullptr if it is empty </dd></dl>

</div>
</div>
<a class="anchor" id="a8935b023185f090c72d432255883de10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html">staticlib::containers::producer_consumer_queue</a>&lt; T &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the queue is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>whether queue is empty </dd></dl>

</div>
</div>
<a class="anchor" id="ad1fa2cd53e50b4889dddc7700d57af4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html">staticlib::containers::producer_consumer_queue</a>&lt; T &gt;::is_full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the queue is full. </p>
<dl class="section return"><dt>Returns</dt><dd>whether queue is full </dd></dl>

</div>
</div>
<a class="anchor" id="a5a6770161ad64f1f62f3b3d473c72dbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html">staticlib::containers::producer_consumer_queue</a>&lt; T &gt;::poll </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read the value at the front to the queue into a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>move (or copy) the value at the front of the queue to given variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns false if queue was empty, true otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a990d1469d76c4b7102de7619c80ee6f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classstaticlib_1_1containers_1_1producer__consumer__queue.html">staticlib::containers::producer_consumer_queue</a>&lt; T &gt;::size_guess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of entries in the queue. </p>
<p>If called by consumer, then true size may be more (because producer may be adding items concurrently). If called by producer, then true size may be less (because consumer may be removing items concurrently). It is undefined to call this from any other thread.</p>
<dl class="section return"><dt>Returns</dt><dd>number of entries in the queue </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>staticlib/containers/<a class="el" href="producer__consumer__queue_8hpp_source.html">producer_consumer_queue.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 10 2015 23:36:46 for staticlib_containers by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
